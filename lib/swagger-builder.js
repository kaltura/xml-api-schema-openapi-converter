const utils = require('./utils');

const DEBUG_OP = {service: '', action: ''};
const _ = require('lodash');

const MAX_QUERY_PARAM_DEPTH = 4;

const DEPRECATED = [
  "document",
  "search",
  "mixing",
  "liveChannel",
  "liveChannelSegment",
]

const BASE_SWAGGER = {
  swagger: '2.0',
  schemes: ['https', 'http'],
};

const TARGET_API = process.env.TARGET_API || 'ovp';
const USE_POST_OPERATIONS = process.env.USE_POST_OPERATIONS === 'false' ? false : true;

if (TARGET_API === 'ott') {
  Object.assign(BASE_SWAGGER, {
    host: 'tvpapi-us-preprod.ott.kaltura.com',
    basePath: '/api_v3',
    info: {title: "Kaltura OTT", description: "The Kaltura OTT API"},
    produces: ['application/json', 'text/xml'],
  })
} else {
  Object.assign(BASE_SWAGGER, {
    host: 'www.kaltura.com',
    basePath: '/api_v3',
    info: {title: "Kaltura VPaaS", description: "The Kaltura VPaaS API"},
  })
}

const getClassnameFromRef = function(ref) {
  return ref.match(/definitions\/(.*)$/)[1];
}
const getRefFromClassname = function(c) {
  return '#/definitions/' + c;
}

const SwaggerBuilder = module.exports = function() {
  this.swagger = Object.assign({}, BASE_SWAGGER);
  this.swagger.security = [{ks: []}];
  if (TARGET_API === 'ovp') {
    this.swagger.securityDefinitions = {
      "ks": {
        in: 'query',
        name: 'ks',
        type: 'apiKey',
        description: 'A session ID generated by calling /service/session/action/start',
      }
    }
  } else {
    this.swagger.securityDefinitions = {
      "ks": {
        in: 'body',
        name: 'ks',
        type: 'apiKey',
        description: 'A Kaltura session ID',
      }
    }
  }
  this.swagger.parameters = {
    ks: {
      name: 'ks',
      in: 'query',
      type: 'string',
      'x-global': true,
    },
    format: {
      name: 'format',
      enum: [1, 2, 3],
      'x-enumLabels': ['JSON', 'XML', 'PHP'],
      'x-consoleDefault': 1,
      description: 'The format of the response',
      in: 'query',
      type: 'integer',
      'x-global': true,
    },
    clientTag: {
      name: 'clientTag',
      type: 'string',
      in: 'query',
      default: 'devkcom',
      'x-hidden':  true,
    }
  }
}

SwaggerBuilder.prototype.run = function(kaltura) {
  this.services = kaltura.services[0].service;
  this.enums = kaltura.enums[0].enum;
  this.classes = kaltura.classes[0].class;
  this.swagger.info.version = kaltura.$.apiVersion;

  this.globalParams = [{$ref: '#/parameters/format'}, {$ref: '#/parameters/clientTag'}]
  this.addRequestConfiguration(kaltura.configurations[0].request[0]);
  this.addEnums();
  this.addDefinitions();
  this.addPaths(kaltura.errors[0].error);
  this.setTags();
  this.addErrors(kaltura.errors[0].error);
  this.finish();
  return this.swagger;
}

SwaggerBuilder.prototype.getClass = function(name) {
  if (name === 'KalturaObjectBase') return {$: {}};
  if (name.indexOf('#') === 0) name = getClassnameFromRef(name);
  return this.classes.filter(c => c.$.name === name)[0];
}

SwaggerBuilder.prototype.getSubclasses = function(name) {
  var subs = [];
  this.classes.forEach(cls => {
    if (cls.$.base === name) subs.push(cls.$.name);
  });

  var addIndirectSubs = (s) => {
    var newSubs = this.getSubclasses(s).filter((name) => {
      return subs.indexOf(name) === -1;
    });
    subs = subs.concat(newSubs);
    newSubs.forEach(addIndirectSubs);
  }
  subs.forEach(addIndirectSubs);

  return subs;
}

SwaggerBuilder.prototype.getSuperclasses = function(name) {
  var cls = this.getClass(name);
  var supers = [];
  if (cls.$.base) supers.push(cls.$.base);
  var superSupers = [];
  supers.forEach((s) => {
    var newSupers = this.getSuperclasses(s).filter(n => superSupers.indexOf(n) === -1);
    superSupers = superSupers.concat(newSupers);
  });
  return superSupers.concat(supers);
}


SwaggerBuilder.prototype.finish = function() {
  this.setInputOptions();
  this.fixDefinitions();
  this.fixFileOperations();
}

SwaggerBuilder.prototype.setTags = function() {
  this.swagger.tags = this.services.map(s => {
    let tag = {
      name: s.$.name,
      description: utils.fixMarkdown(s.$.description),
    };
    if (s.$.plugin) tag['x-plugin'] = s.$.plugin;
    return tag;
  })
  .sort(function(t1, t2) {
    return t1.name.toLowerCase() > t2.name.toLowerCase() ? 1 : -1;
  })
}

SwaggerBuilder.prototype.addRequestConfiguration = function(config) {
  for (let key in config) {
    if (key === '$') continue;
    if (key in this.swagger.parameters) continue;
    let kparam = config[key][0];
    let param = this.swagger.parameters[key] = {
      name: key,
      in: kparam.$.type.startsWith('Kaltura') ? 'body' : 'query',
      'x-global': true,
      'x-volatile': kparam.$.volatile === '1',
    }
    if (param.in === 'body') {
      param.schema = {
        type: 'object',
        properties: {}
      }
      param.schema.properties[key] = {$ref: '#/definitions/' + kparam.$.type}
    } else {
      param.type = utils.convertType(kparam.$.type);
    }
    this.globalParams.push({$ref: '#/parameters/' + key})
  }
}

SwaggerBuilder.prototype.addEnums = function() {
  this.swagger['x-enums'] = {};
  this.enums.forEach(enm => {
    var values = (enm.const || []).map(c => {
      var value = c.$.value;
      if (enm.$.enumType === 'int') value = parseInt(value)
      return {value, name: c.$.name};
    })
    this.swagger['x-enums'][enm.$.name] = {
      title: enm.$.name,
      oneOf: values.map(v => {
        return {
          title: v.name,
          enum: [v.value],
        }
      }),
    }
  })
}

SwaggerBuilder.prototype.addDefinitions = function() {
  this.swagger.definitions = {KalturaObjectBase: {}};
  if (TARGET_API === 'ott') {
    this.swagger.definitions.OTTRequest = {
      type: 'object',
      properties: {
        ks: {type: 'string'},
        version: {
          type: 'string',
          default: this.swagger.info.version,
        },
      }
    }
  }

  let getAllBases = (def) => {
    let bases = this.classes.filter(sub => sub.$.base === def);
    let transitive = bases.reduce((cur, next) => {
      return cur.concat(getAllBases(next.$.name));
    }, []);
    return bases.filter(b => b.$.abstract !== "1").map(b => b.$.name).concat(transitive);
  }

  this.classes.forEach((cls) => {
    var def = this.swagger.definitions[cls.$.name] = {
      title: cls.$.name,
      type: 'object',
      properties: {},
    };
    if (cls.$.base) {
      def.allOf = [{$ref: getRefFromClassname(cls.$.base)}];
    }
    let subs = getAllBases(cls.$.name);
    if (subs.length) {
      def['x-abstract'] = cls.$.abstract && cls.$.abstract !== "0"
      def.anyOf = subs.map(s => ({$ref: getRefFromClassname(s)}));
      let enumVals = subs.map(s => s);
      if (!def['x-abstract']) {
        def.anyOf.unshift({$ref: getRefFromClassname(cls.$.name)});
        enumVals.unshift(cls.$.name);
      }
      def.discriminator = 'objectType';
      def.properties.objectType = {type: 'string', enum: enumVals};
    }
    let descriptionParts = [
      utils.extractPropertiesAsMarkdown(cls),
      utils.fixMarkdown(cls.$.description),
    ];
    def.description = descriptionParts.filter(p => p).join('\n\n') || undefined;
    if (cls.$.name.match(/Filter$/i)) {
      let enumName = cls.$.name.replace('Filter', 'OrderBy');
      let enm = this.swagger['x-enums'][enumName];
      if (enm) {
        let swaggerProp = def.properties.orderBy = {type: 'string'};
        swaggerProp.enum = enm.oneOf.map(v => v.enum[0]);
        if (!swaggerProp.enum.length) delete swaggerProp.enum;
        swaggerProp['x-enumLabels'] = enm.oneOf.map(v => v.title);
        swaggerProp['x-enumType'] = enumName;
      }
    }
    var props = cls.property || [];
    props.forEach((prop) => {
      var swaggerProp = def.properties[prop.$.name] = {};
      if (prop.$.type.indexOf('Kaltura') === 0) {
        swaggerProp.$ref = getRefFromClassname(prop.$.type);
        return;
      } else if (prop.$.arrayType && prop.$.arrayType.indexOf('Kaltura') === 0) {
        swaggerProp.type = 'array';
        swaggerProp.items = {$ref: getRefFromClassname(prop.$.arrayType)};
        return;
      }
      if (prop.$.readOnly && prop.$.readOnly !== '0') {
        swaggerProp.readOnly = true;
      }

      let descriptionParts = [
        utils.extractPropertiesAsMarkdown(prop),
      ];
      swaggerProp.type = utils.convertType(prop.$.type);
      if (prop.$.enumType) {
        descriptionParts.push('Enum Type: `' + prop.$.enumType + '`');
        var enm = this.swagger['x-enums'][prop.$.enumType];
        let enumOptions = utils.getUniqueEnumOptions(enm);
        swaggerProp.enum = enumOptions.map((opt) => {
          return swaggerProp.type === 'integer' ? parseInt(opt.enum[0]) : opt.enum[0];
        });
        if (!swaggerProp.enum.length) delete swaggerProp.enum;
        swaggerProp['x-enumType'] = prop.$.enumType;
        if (prop.$.enumType !== 'KalturaLanguage') {
          swaggerProp['x-enumLabels'] = enumOptions.map((opt) => {
            return opt.title;
          })
        }
      }
      descriptionParts.push(utils.fixMarkdown(prop.$.description))
      let desc = descriptionParts.filter(p => p).join('\n\n');
      if (desc) swaggerProp.description = desc;
    })
  });
}

SwaggerBuilder.prototype.initializeOperation = function(op, service, action) {
  op.description = utils.fixMarkdown(action.$.description);
  op.tags = [service.$.name];
  op.operationId = service.$.name + '.' + action.$.name;
  if (action.$.deprecated) {
    op.deprecated = true;
  }
  if (action.$.beta) {
    op['x-beta'] = true;
  }
}

SwaggerBuilder.prototype.createGetOperation = function(service, action, path, expandedParams) {
  const log = DEBUG_OP.service === service.$.id && DEBUG_OP.action == action.$.name;
  let op = path.get = {};
  op['x-kaltura-format'] = 'get';
  op['x-kaltura-parameters'] = [];
  this.initializeOperation(op, service, action);
  op.parameters = [{
    $ref: '#/parameters/format',
  }];
  if (action.$.sessionRequired === 'none') {
    op.security = [];
  } else {
    op.parameters.unshift({
      $ref: '#/parameters/ks',
    })
  }
  var parameters = action.param || [];
  parameters.forEach((param) => {
    op['x-kaltura-parameters'].push(param.$.name)
    if (param.$.type.indexOf('Kaltura') === 0) {
      var exParams = expandedParams[param.$.type];
      if (!exParams) {
        exParams = expandedParams[param.$.type] = this.getExpandedQueryParameters(param.$.type);
      }
      op['x-parameterGroups'] = op['x-parameterGroups'] || [];
      var GROUP_REGEX = /(.*)\[[^\]]+\]$/;
      var getGroup = (name, groups) => {
        var groups = groups || op['x-parameterGroups'];
        var group = groups.filter(g => g.name === name)[0];
        if (group) return group;
        return groups.filter(g => g.subGroups).map(g => getGroup(name, g.subGroups)).filter(g => g)[0];
      }
      addGroup = (name) => {
        if (getGroup(name)) return;
        var parentGroup = name.match(GROUP_REGEX)[1];
        parentGroup = getGroup(parentGroup);
        parentGroup.subGroups = parentGroup.subGroups || [];
        parentGroup.subGroups.push({name: name})
      }
      op['x-parameterGroups'].push({
        name: param.$.name,
        description: 'Object Type: `' + param.$.type + '`',
        schema: {$ref: getRefFromClassname(param.$.type)},
        subGroups: [],
      });
      this.swagger.parameters = this.swagger.parameters || {};
      exParams.forEach(exParam => {
        exParam = JSON.parse(JSON.stringify(exParam));
        exParam.name = param.$.name + exParam.name;
        var group = exParam.name.match(/(.*)\[[^\]]+\]$/)[1];
        exParam['x-group'] = group;
        addGroup(group)
        if (exParam['x-showCondition']) exParam['x-showCondition'].name = param.$.name + exParam['x-showCondition'].name;
        let refKey = param.$.type + ':' + exParam.name;
        this.swagger.parameters[refKey] = exParam;
        op.parameters.push({$ref: '#/parameters/' + refKey});
      });
      if (log) console.log('exparam', exParams);
      return;
    } else if (param.$.type === "array") {
      return;
    }
    var newParam = {
      name: param.$.name,
      in: 'query',
      description: utils.fixMarkdown(param.$.description),
      type: utils.convertType(param.$.type),
      required: param.$.optional !== "1",
    };
    let def = utils.parseDefault(param.$.default, newParam.type);
    if (def !== undefined) newParam.default = def;

    var enm = this.swagger['x-enums'][param.$.enumType];
    if (enm) {
      var msg = 'Enum Type: `' + param.$.enumType + '`';
      newParam.description = msg + (newParam.description ? '\n\n' + newParam.description : '');
      let enumOptions = utils.getUniqueEnumOptions(enm);
      newParam.enum = enumOptions.map(e => e.enum[0]);
      if (!newParam.enum.length) delete newParam.enum;
      newParam['x-enumLabels'] = enumOptions.map(e => e.title)
      newParam['x-enumType'] = enm.title;
    }
    if (log) console.log('param', newParam);
    op.parameters.push(newParam)
  });
  return op;
}

SwaggerBuilder.prototype.createPostOperation = function(service, action, path) {
  const log = false;
  let op = path.post = {};
  op['x-kaltura-format'] = 'post';
  this.initializeOperation(op, service, action);
  let bodyParam = {
    name: 'body',
    in: 'body',
    schema: {
      type: 'object',
      properties: {}
    }
  };
  op.parameters = this.globalParams.concat([bodyParam]);
  if (TARGET_API === 'ott') {
    bodyParam.schema.allOf = [{$ref: '#/definitions/OTTRequest'}];
  } else {
    if (action.$.sessionRequired === 'none') {
      op.security = [];
    } else {
      op.parameters.unshift({
        $ref: '#/parameters/ks',
      })
    }
  }
  if (!action.param || !action.param.length) {
    op.parameters = op.parameters.filter(p => p !== bodyParam);
  }
  op['x-kaltura-parameters'] = (action.param || []).map(p => p.$.name);
  let requiredParams = (action.param || []).filter(p => p.$.optional !== "1").map(p => p.$.name);
  if (requiredParams.length) bodyParam.schema.required = requiredParams;
  (action.param || []).forEach(param => {
    let pSchema = bodyParam.schema.properties[param.$.name] = {};
    if (param.$.type.indexOf('Kaltura') === 0) {
      pSchema.$ref = getRefFromClassname(param.$.type);
    } else {
      pSchema.type = utils.convertType(param.$.type);
      if (pSchema.type === 'array') {
        pSchema.items = {$ref: getRefFromClassname(param.$.arrayType)};
      }
      let dft = utils.parseDefault(param.$.default, pSchema.type);
      if (dft !== undefined) pSchema.default = dft;
      let enm = this.swagger['x-enums'][param.$.enumType];
      if (enm) {
        let enumOptions = utils.getUniqueEnumOptions(enm);
        pSchema.enum = enumOptions.map(e => e.enum[0]);
        pSchema['x-enumLabels'] = enumOptions.map(e => e.title);
        pSchema['x-enumType'] = param.$.enumType;
      }
    }
  });
  return op;
}

SwaggerBuilder.prototype.addPaths = function(errors) {
  this.swagger.paths = {};
  let expandedParams = {}
  this.services.forEach((service) => {
    if (DEPRECATED.indexOf(service.$.name) !== -1) return;
    var actions = service.action;
    actions.forEach((action) => {
      var pathname = '/service/' + service.$.id + '/action/' + action.$.name;
      console.log('\n\n', pathname);
      var path = this.swagger.paths[pathname] = {};
      var log = DEBUG_OP.service === service.$.id && DEBUG_OP.action == action.$.name;
      let hasFileParam = !!(action.param || []).filter(p => p.$.type === 'file').length
      let op = USE_POST_OPERATIONS && !hasFileParam?
            this.createPostOperation(service, action, path)
            : this.createGetOperation(service, action, path, expandedParams);
      op.responses = {
        '200': {
          description: 'Success',
        }
      }

      function getResponseSchema(type, arrayType) {
        if (type.indexOf('Kaltura') === 0) {
          return {'$ref': getRefFromClassname(type)};
        } else {
          let schema = {type: utils.convertType(result.$.type)};
          if (schema.type === 'file') schema.type = 'string'
          if (schema.type === 'array') {
            schema.items = getResponseSchema(arrayType);
          }
          return schema;
        }
      }
      var result = action.result[0];
      if (result) {
        op.responses['200'].schema = getResponseSchema(result.$.type, result.$.arrayType);
      }
      if (action.throws) {
        let errResp = op.responses['x-Errors'] = {description: ""};
        action.throws.filter(t => t.$).forEach(t => {
          let errName = t.$.name;
          if (errResp.description) errResp.description += '\n';
          errResp.description += '* `' + errName + '`';
          let details = errors.filter(e => e.$.name === errName)[0];
          let message = details && (details.$.message || details.$.description);
          if (message) errResp.description += ': ' + message;
        })
      }
    });
  });
}

SwaggerBuilder.prototype.getExpandedQueryParameters = function(definitionName) {
  var params = [];
  var addParams = (defName, baseName, cond, skipSuper, skipSub) => {
    baseName = baseName || '';
    if (baseName.split(/\[/).length > MAX_QUERY_PARAM_DEPTH) return;
    var def = this.swagger.definitions[defName];
    if (!def) throw new Error("Definition " + defName + " not found")

    if (!skipSuper) {
      var superclasses = this.getSuperclasses(defName);
      superclasses.forEach((sc) => {
        addParams(sc, baseName, cond, true, true);
      })
    }

    var props = def.properties;
    for (var prop in props) {
      var propDef = props[prop];
      if (propDef.readOnly) continue;
      if (propDef.$ref) {
        var subDef = getClassnameFromRef(propDef.$ref);
        addParams(subDef, baseName + '[' + prop + ']', cond, false, false)
        continue;
      }
      var items = undefined;
      if (propDef.items) {
        items = {anyOf: [propDef.items], type: 'object'};
        if (propDef.items.$ref) {
          var subDef = getClassnameFromRef(propDef.items.$ref);
          items.anyOf = items.anyOf.concat(this.getSubclasses(subDef).map(c => ({$ref: getRefFromClassname(c)})));
        }
      }
      var newParam = {
        type: propDef.type,
        items: items,
        in: 'query',
        name: baseName + '[' + prop + ']',
        enum: propDef.enum,
        'x-enumLabels': propDef['x-enumLabels'],
        'x-enumType': propDef['x-enumType'],
        description: propDef.description,
      };
      if (!newParam.enum && prop === 'orderBy') {
        let enumName = definitionName.replace('Filter', 'OrderBy');
        let enm = this.swagger['x-enums'][enumName];
        if (enm) {
          newParam.enum = enm.oneOf.map(v => v.enum[0]);
          if (!newParam.enum.length) delete newParam.enum;
          newParam['x-enumLabels'] = enm.oneOf.map(v => v.title);
          newParam['x-enumType'] = enumName;
        }
      }
      var oldParam = params.filter(p => p.name === newParam.name)[0];
      if (oldParam) {
        if (oldParam['x-showCondition']) {
          oldParam['x-showCondition'].value = oldParam['x-showCondition'].value.concat(cond.value);
          oldParam['x-showCondition'].value = _.uniq(oldParam['x-showCondition'].value);
        }
      } else {
        if (cond) newParam['x-showCondition'] = cond;
        params.push(newParam);
      }
    }

    if (!skipSub) {
      var subclasses = this.getSubclasses(defName);
      if (subclasses.length) {
        var paramName = baseName + '[objectType]';
        var existing = params.filter(p => p.name === paramName)[0];
        if (!existing) {
          params.push({
            name: paramName,
            in: 'query',
            enum: subclasses,
            type: 'string',
          });
        } else {
          subclasses = subclasses.filter(s => existing.enum.indexOf(s) === -1);
          existing.enum = _.uniq(existing.enum.concat(subclasses));
        }
        subclasses.forEach((subName) => {
          addParams(subName, baseName, {name: paramName, value: [subName]}, false, false);
        })
      }
    }
  }
  addParams(definitionName);
  return params;
}

SwaggerBuilder.prototype.fixDefinitions = function() {
  for (let def in this.swagger.definitions) {
    this.fixSchema(this.swagger.definitions[def]);
  }
}

SwaggerBuilder.prototype.fixSchema = function(schema) {
  if (schema.type === 'file') schema.type = 'string';
  if (schema.items) this.fixSchema(schema.items);
  if (schema.properties) {
    for (let key in schema.properties) {
      this.fixSchema(schema.properties[key])
    }
  }
}

SwaggerBuilder.prototype.fixFileOperations = function() {
  for (var path in this.swagger.paths) {
    var op = this.swagger.paths[path].get;
    if (!op) continue;
    var fileParams = op.parameters.map(p => {
      if (!p.$ref) return p;
      let ref = p.$ref.match(/#\/parameters\/(.*)$/)[1];
      return this.swagger.parameters[ref];
    }).filter(p => p.type === 'file');
    if (!fileParams.length) continue;
    op['x-kaltura-format'] = 'file';
    fileParams.forEach(p => p.in = 'formData');
    this.swagger.paths[path].post = op;
    delete this.swagger.paths[path].get;
  }
}

SwaggerBuilder.prototype.setInputOptions = function() {
  const addDynEnum = (p, name) => {
    let path = '/service/' + name + '/action/list';
    if (!this.swagger.paths[path]) return;
    let label = name === 'media' ? 'name' : 'id';
    if (p.type === 'number' || p.type === 'integer') {
      p['x-inputType'] = 'number';
    } else {
      p['x-inputType'] = 'text';
    }
    p['x-dynamicEnum'] = {
      path: '/service/' + name + '/action/list',
      method: USE_POST_OPERATIONS ? 'post' : 'get',
      array: 'objects',
      label: label,
      value: 'id',
    }
  }

  const adjustParameter = (p, schema, path) => {
    if (p.$ref) return;
    var isGet = path && path.match(/\/get$/);
    if (p.name === 'password' || p.name === 'secret') p['x-inputType'] = 'password';
    if (p.name.match(/Date\]?$/)) p['x-inputType'] = 'datetime';
    if (p.name === 'entryId' && isGet && path.startsWith('/service/media/')) {
      addDynEnum(p, 'media', {properties: {name: {type: 'string'}}});
      p['x-inputType'] = p.type === 'number' ? 'number' : 'text';
    }
    if (path === '/service/session/action/start' && p.name === 'expiry') {
      p.default = 86400;
    }
  }

  const adjustSchema = (schema, path='') => {
    var isGet = path.match(/\/get$/);
    for (let prop in schema.properties || {}) {
      if (isGet && path.startsWith('/service/media/') && prop === 'entryId') {
        addDynEnum(schema.properties[prop], 'media');
      }
      if (prop === 'password' || prop === 'secret') {
        schema.properties[prop]['x-inputType'] = 'password';
      } else if (prop.match(/Date$/)) {
        schema.properties[prop]['x-inputType'] = 'datetime';
      } else if (prop === 'expiry' && path === '/service/session/action/start') {
        schema.properties[prop].default = 86400;
      }
      adjustSchema(schema.properties[prop])
    }
    if (schema.items) adjustSchema(schema.items);
  }

  for (var path in this.swagger.paths) {
    var op = this.swagger.paths[path].get || this.swagger.paths[path].post;
    var schema = op.responses['200'].schema;
    if (schema) schema = this.resolveRef(schema);
    (op.parameters || []).forEach(p => adjustParameter(p, schema, path));
    let bodyParam = op.parameters.filter(p => p.in === 'body').pop();
    if (bodyParam && bodyParam.schema) {
      adjustSchema(bodyParam.schema, path);
    }
  }
  for (var key in this.swagger.definitions) {
    adjustSchema(this.swagger.definitions[key]);
  }
  Object.keys(this.swagger.parameters || {}).map(k => this.swagger.parameters[k]).forEach(p => adjustParameter(p));
}

SwaggerBuilder.prototype.addErrors = function(errors) {
  this.swagger['x-errors'] = errors.map(err => {
    return err.$;
  })
}

SwaggerBuilder.prototype.resolveRef = function(schema) {
  var ref = schema.$ref;
  if (!ref) return schema;
  return this.swagger.definitions[getClassnameFromRef(ref)];
}
