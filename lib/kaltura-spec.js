'use strict';
var FS = require('fs');
var Inherits = require('util').inherits;
var Converter = require('api-spec-converter');
var xml2js = require('xml2js');
var Promise = require('bluebird');
var _ = require('lodash');

var DEBUG_OP = {service: '', action: ''};
var DEPRECATED = [
  "document",
  "search",
  "mixing",
  "liveChannel",
  "liveChannelSegment",
]

function resolveRef(base, schema) {
  var ref = schema.$ref;
  if (!ref) return schema;
  ref = ref.substring('#/definitions/'.length);
  return base.definitions[ref];
}

function fixMarkdown(str) {
  if (!str) return;
  var ret = str.replace(/\n\s*\t\s*/g, '\n\n').trim();
  return ret || undefined;
}
var Kaltura = module.exports = function() {
  Kaltura.super_.apply(this, arguments);
  this.type = 'kaltura';
  this.converters.swagger_2 = Promise.method(kaltura => convertToSwagger(kaltura.spec.xml))
};
Inherits(Kaltura, Converter.BaseFormat);

Kaltura.prototype.formatName = 'kaltura';
Kaltura.prototype.supportedVersions = ['1.0'];
Kaltura.prototype.getFormatVersion = function () {
  return '1.0';
}

Kaltura.prototype.parsers = {
  'XML': data => Promise.promisify(xml2js.parseString)(data)
};

Kaltura.prototype.checkFormat = function (spec) {
  return true;
}

var convertToSwagger = function(kaltura) {
  var swagger = {swagger: '2.0'};
  swagger.host = 'www.kaltura.com';
  swagger.schemes = ['http', 'https'];
  swagger.basePath = '/api_v3';
  swagger.info = {title: 'Kaltura', description: 'The Kaltura API'};
  swagger.info.version = kaltura.$.apiVersion;
  swagger.securityDefinitions = {
    "ks": {
      in: 'query',
      name: 'ks',
      type: 'apiKey',
      description: 'A session ID generated by calling /service/session/action/start',
    }
  }
  var services = kaltura.services[0].service;
  var enums = kaltura.enums[0].enum;
  enums = convertEnums(enums);
  var classes = kaltura.classes[0].class;
  swagger.definitions = convertClasses(classes, enums);
  swagger['x-enums'] = {}
  for (var key in enums) {
    swagger['x-enums'][key] = {
      "oneOf":  enums[key].map(function(e) {
        return {"enum": [e.value], title: e.name}
      }),
    }
  }
  var expandedParams = {};
  swagger.parameters = {
    format: {
      name: 'format',
      enum: [1, 2, 3],
      'x-enumLabels': ['JSON', 'XML', 'PHP'],
      description: 'The format of the response',
      in: 'query',
      type: 'integer',
      'x-global': true,
    }
  };
  swagger.paths = convertServices(services, enums, swagger.definitions);
  swagger.tags = [];
  services.forEach(function(s) {swagger.tags.push({
    name: s.$.name,
    description: fixMarkdown(s.$.description),
  })})
  swagger.tags = swagger.tags.sort(function(t1, t2) {
    return t1.name > t2.name ? 1 : -1;
  })

  setInputOptions(swagger);
  fixFileOperations(swagger);
  return swagger;
}

var convertEnums = function(enums) {
  var ret = {};
  enums.forEach(function(enm) {
    ret[enm.$.name] = (enm.const || []).map(function(c) {
      var value = c.$.value;
      if (enm.$.enumType === 'int') value = parseInt(value)
      return {name: c.$.name, value: value}
    })
  })
  return ret;
}

var convertClasses = function(classes, enums) {
  var definitions = {KalturaObjectBase: {}};
  classes.forEach(function(cls) {
    var base = cls.$.base;
    var def = definitions[cls.$.name] = {};
    if (base) def.allOf = [{$ref: '#/definitions/' + base}];
    let descriptionParts = [
      extractPropertiesAsMarkdown(cls),
      fixMarkdown(cls.$.description),
    ];
    def.description = descriptionParts.filter(p => p).join('\n\n') || undefined;
    def.properties = {};
    var props = cls.property || [];
    props.forEach(function(prop) {
      var swaggerProp = def.properties[prop.$.name] = {};
      if (prop.$.type.indexOf('Kaltura') === 0) {
        swaggerProp.$ref = '#/definitions/' + prop.$.type;
        return;
      } else if (prop.$.arrayType && prop.$.arrayType.indexOf('Kaltura') === 0) {
        swaggerProp.type = 'array';
        swaggerProp.items = {$ref: '#/definitions/' + prop.$.arrayType};
        return;
      }
      if (prop.$.readOnly && prop.$.readOnly !== '0') {
        swaggerProp.readOnly = true;
      }

      let descriptionParts = [
        extractPropertiesAsMarkdown(prop),
      ];
      swaggerProp.type = convertType(prop.$.type);
      if (prop.$.enumType) {
        descriptionParts.push('Enum Type: `' + prop.$.enumType + '`');
        var enm = enums[prop.$.enumType];
        var allVals = enm.map(e => e.value);
        enm = enm.filter(e => allVals.indexOf(e.value) === allVals.lastIndexOf(e.value));
        swaggerProp.enum = enm.map(function(e) {
          return swaggerProp.type === 'integer' ? parseInt(e.value) : e.value;
        });
        if (prop.$.enumType !== 'KalturaLanguage') {
          swaggerProp['x-enumLabels'] = enm.map(function(e) {
            return e.name;
          })
        }
      }
      descriptionParts.push(fixMarkdown(prop.$.description))
      let desc = descriptionParts.filter(p => p).join('\n\n');
      if (desc) swaggerProp.description = desc;
    })
  });
  return definitions;
}

var convertServices = function(services, enums, definitions) {
  var paths = {};
  var expandedParams = {};
  services.forEach(function(service) {
    if (DEPRECATED.indexOf(service.$.name) !== -1) return;
    var actions = service.action;
    actions.forEach(function(action) {
      var path = '/service/' + service.$.id + '/action/' + action.$.name;
      console.log('\n\n', path);
      var log = DEBUG_OP.service === service.$.id && DEBUG_OP.action == action.$.name;
      path = paths[path] = {};
      path = path.get = {};
      path.description = fixMarkdown(action.$.description);
      path.tags = [service.$.name];
      path.operationId = service.$.name + '.' + action.$.name;
      if (log) console.log('path', path);
      path.parameters = [{
        $ref: '#/parameters/format',
      }];
      var parameters = action.param || [];
      parameters.forEach(function(param) {
        if (param.$.type.indexOf('Kaltura') === 0) {
          var exParams = expandedParams[param.$.type];
          if (!exParams) {
            exParams = expandedParams[param.$.type] = getExpandedQueryParameters(param.$.type, enums, definitions);
          }
          path['x-parameterGroups'] = path['x-parameterGroups'] || [];
          var group = {
            name: param.$.name,
            description: 'Object Type: `' + param.$.type + '`',
            subGroups: [],
          };
          var GROUP_REGEX = /(.*)\[[^\]]+\]$/;
          function getGroup(name, groups) {
            var groups = groups || path['x-parameterGroups'];
            var group = groups.filter(g => g.name === name)[0];
            if (group) return group;
            return groups.filter(g => g.subGroups).map(g => getGroup(name, g.subGroups)).filter(g => g)[0];
          }
          function addGroup(name) {
            if (getGroup(name)) return;
            var parentGroup = name.match(GROUP_REGEX)[1];
            parentGroup = getGroup(parentGroup);
            parentGroup.subGroups = parentGroup.subGroups || [];
            parentGroup.subGroups.push({name: name})
          }
          path['x-parameterGroups'].push(group);
          exParams = exParams.map(function(p) {
            p = JSON.parse(JSON.stringify(p));
            p.name = param.$.name + p.name;
            var group = p.name.match(/(.*)\[[^\]]+\]$/)[1];
            p['x-group'] = group;
            addGroup(group)
            if (p['x-showCondition']) p['x-showCondition'].name = param.$.name + p['x-showCondition'].name;
            return p;
          });
          path.parameters = path.parameters.concat(exParams);
          if (log) console.log('exparam', exParams);
          return;
        } else if (param.$.type === "array") {
          return;
        }
        var newParam = {
          name: param.$.name,
          in: 'query',
          description: fixMarkdown(param.$.description),
          type: convertType(param.$.type),
          required: param.optional === 1,
        };
        var enumVals = enums[param.$.enumType];
        if (enumVals) {
          var msg = 'Enum Type: `' + param.$.enumType + '`';
          newParam.description = msg + (newParam.description ? '\n\n' + newParam.description : '');
          var allVals = enumVals.map(e => e.value);
          enumVals = enumVals.filter(e => allVals.indexOf(e.value) === allVals.lastIndexOf(e.value));
          newParam.enum = enumVals.map(e => e.value);
          newParam['x-enumLabels'] = enumVals.map(function(e) {return e.name})
        }
        if (log) console.log('param', newParam);
        path.parameters.push(newParam)
      });
      path.responses = {
        '200': {
          description: 'Success',
        }
      }
      var result = action.result[0];
      if (result) {
        var resultType = result.$.type;
        if (resultType.indexOf('Kaltura') === 0) {
          path.responses['200'].schema = {'$ref': '#/definitions/' + result.$.type}
        }
      }
    });
  });
  return paths;
}

var getExpandedQueryParameters = function(defName, enums, definitions) {
  function getSubclasses(defName) {
    var subs = Object.keys(definitions).filter(function(label) {
      var def = definitions[label];
      var inherits = (def.allOf || []).filter(function(i) {
        return i.$ref === '#/definitions/' + defName;
      })
      return inherits.length;
    });

    var indirSubs = [];
    function addIndirectSubs(s) {
      var newSubs = getSubclasses(s).filter(function(name) {
        return indirSubs.indexOf(name) === -1 && subs.indexOf(name) === -1;
      });
      indirSubs = indirSubs.concat(newSubs);
      newSubs.forEach(addIndirectSubs);
    }
    subs.forEach(addIndirectSubs);

    return subs.concat(indirSubs);
  }

  function getSuperclasses(defName) {
    var def = definitions[defName];
    var supers = (def.allOf || []).map(s => s.$ref.substring('#/definitions/'.length));
    var superSupers = [];
    supers.forEach(function(s) {
      var newSupers = getSuperclasses(s).filter(n => superSupers.indexOf(n) === -1);
      superSupers = superSupers.concat(newSupers);
    });
    return superSupers.concat(supers);
  }

  var params = [];
  var addParams = function(defName, baseName, cond, skipSuper, skipSub) {
    baseName = baseName || '';
    if (baseName.split(/\[/).length > 4) return;
    var def = definitions[defName];
    if (!def) throw new Error("Definition " + defName + " not found")

    if (!skipSuper) {
      var superclasses = getSuperclasses(defName);
      superclasses.forEach(function(sc) {
        addParams(sc, baseName, cond, true, true);
      })
    }

    var props = def.properties;
    for (var prop in props) {
      var propDef = props[prop];
      if (propDef.readOnly) continue;
      if (propDef.$ref) {
        var subDef = propDef.$ref.match(/definitions\/(.*)$/)[1];
        addParams(subDef, baseName + '[' + prop + ']', cond, false, false)
        return;
      }
      var newParam = {
        type: propDef.type,
        in: 'query',
        name: baseName + '[' + prop + ']',
        enum: propDef.enum,
        'x-enumLabels': propDef['x-enumLabels'],
        description: propDef.description,
      };
      if (newParam.type === 'array') continue;
      var oldParam = params.filter(p => p.name === newParam.name)[0];
      if (oldParam) {
        if (oldParam['x-showCondition']) {
          oldParam['x-showCondition'].value = oldParam['x-showCondition'].value.concat(cond.value);
          oldParam['x-showCondition'].value = _.uniq(oldParam['x-showCondition'].value);
        } else {
          oldParam['x-showCondition'] = cond;
        }
      } else {
        if (cond) newParam['x-showCondition'] = cond;
        params.push(newParam);
      }
    }

    if (!skipSub) {
      var subclasses = getSubclasses(defName);
      if (subclasses.length) {
        var paramName = baseName + '[objectType]';
        var existing = params.filter(p => p.name === paramName)[0];
        if (!existing) {
          params.push({
            name: paramName,
            in: 'query',
            enum: subclasses,
            type: 'string',
          });
        } else {
          existing.enum = _.uniq(existing.enum.concat(subclasses));
        }
      }
      subclasses.forEach(function(subName) {
        addParams(subName, baseName, {name: paramName, value: [subName]}, true, true);
      })
    }
  }
  addParams(defName);
  return params;
}

var convertType = function(type) {
  if (type === "bool") return "boolean";
  if (type === "array") return "array";
  if (type === "int" || type === "bigint") return "integer";
  if (type === "float") return "number";
  if (type === "string") return "string";
  if (type === "map") return "object";
  if (type === "file") return "file";
  throw new Error("Unknown type:" + type);
}

var setInputOptions = function(swagger) {
  function addDynEnum(p, name, schema) {
    var label = schema && 'name' in schema.properties ? 'name' : 'id';
    p['x-dynamicEnum'] = {
      path: '/service/' + name + '/action/list',
      method: 'get',
      array: 'objects',
      label: label,
      value: 'id',
    }
  }

  function adjustParameter(p, schema, isGet) {
    if (p.$ref) return;
    if (p.name === 'password') p['x-inputType'] = 'password';
    if (p.name.match(/Date\]?$/)) p['x-inputType'] = 'datetime';
    if (p.name === 'id' && isGet && schema) {
      addDynEnum(p, path.match(/service\/([^\/]*)\//)[1], schema);
      p['x-inputType'] = p.type === 'number' ? 'number' : 'text';
    }
    if (p.name === 'entryId' && isGet) {
      addDynEnum(p, 'media', {properties: {name: {type: 'string'}}});
      p['x-inputType'] = p.type === 'number' ? 'number' : 'text';
    }
  }

  for (var path in swagger.paths) {
    var op = swagger.paths[path].get;
    var isGet = path.match(/\/get$/);
    var schema = op.responses['200'].schema;
    if (schema) schema = resolveRef(swagger, schema);
    (op.parameters || []).forEach(p => adjustParameter(p, schema, isGet));
  }
  Object.keys(swagger.parameters).map(k => swagger.parameters[k]).forEach(adjustParameter);
}
var fixFileOperations = function(swagger) {
  for (var path in swagger.paths) {
    var op = swagger.paths[path].get;
    var fileParams = op.parameters.filter(p => p.type === 'file');
    if (!fileParams.length) continue;
    fileParams.forEach(p => p.in = 'formData');
    swagger.paths[path].post = op;
    delete swagger.paths[path].get;
  }
}

var extractPropertiesAsMarkdown = function(item) {
  let props = [];
  const FIELDS = ['readOnly', 'insertOnly', 'writeOnly', 'abstract', 'optional', 'enableInMultiRequest'];
  FIELDS.forEach(f => {
    if (item.$[f] && item.$[f] !== '0') props.push(f);
  })
  return props.map(p => '`' + p + '`').join(' ');
}
